# 关于SimplePIM代码结构

## 一、总体简述  
  SimplePIM本身是一个host端的库，但为了实现一些设计，在项目中引入了一些写死了的DPU端代码，也定义了一些“约定俗成”的规矩，让使用它的项目必须要遵守这个规则，或是命名规则、或是路径规则。  
  
  SimplePIM中带有的benchmark很好地遵循了这些规则，并且使用Makefile手动管理依赖的文件（一个一个捋清依赖），从而把这个库硬是糊进整个项目里，完成编译和运行。

  对于该库，由于一些原因（下面会讲到），在不动原始代码的情况下建立一个单独的二进制库是不现实的，所以了解它的具体结构是很有必要的。

## 二、代码层次结构
  根据原论文叙述，SimplePIM给用户级代码提供的接口分为三类：  
- ### 管理（Manegement）接口  
  该接口所涉及到的数据结构和方法十分重要，有负责管理所有数组的simplepim_management_t和单个数组的元数据类型table_host_t。这些数据结构以及对应的若干方法，可以让host端通过驻留在内存的结构体来簿记dpu的MRAM使用情况，并管理数组元数据的增删改查。  
  带有一个命名比较迷惑的DPU kernel SmallTableInit_dpu.c以及对应的host端编译+执行的外壳SmallTableInit.c，其实就是用来把DPU里的堆内存全都清干净。  
  特别需要注意的是，simplepim_management_t的定义中涉及到和processing接口的耦合，这一点在重构的时候需要注意。
- ### 通信（Communication）接口  
  该接口没有新引入数据结构，主要是围绕simplepim_management_t实现通信的缓冲区准备以及通信算法本身，可以和management一起被拎出来单独使用，有一定的复用价值。  
  本接口没有额外定义DPU Kernel。
- ### 处理（Processing）接口
  这个接口在我看来是一个较为混乱的部分，它主要实现了三个算子以及简单的二进制生成（hack）功能，实现得十分不优雅，而且没有考虑到可维护性。  
  首先从ProcessingHelperHost看起，它定义了一个数据结构handle_t用来管理DPU代码编译后的**路径**，以及host端按照SimplePIM要求的格式书写的c代码——生成的动态库so的**路径**，还有该功能的type（MAP、RED、ZIP三选一）,其中只有ZIP不需要用户单独按照要求写程序，其他的操作在使用的时候都需要用户按照指定的文件路径、文件名书写自己的算子。  
  这些算子拥有固定的返回值和形参类型（可以理解为统一的函数指针），依赖动态链接的方式。 然后根据用户传进来的代码文件名以及功能类型，在C内操作shell进行编译，并且生成handle_t，因此，该接口无法与用户层解耦，没办法构造静态库。  
  该模块对MAP、REDUCE和ZIP都有对应的CPU以及DPU kernel的实现，用户可以干预MAP和REDUCE的一小部分（通过前面编译出来的、动态链接库的函数指针），感觉这三个相对于算子而言，更像是三种算子范式，但不得不说这个模块hack地有些许过分了。  

除了三类接口，根目录下还有一些DPU的函数以及Host端的接口，定义了一些Host、DPU以及共有的数据结构和它们对应的操作，一些是暴露给用户的，另一些则是与REDUCE算子强相关的。